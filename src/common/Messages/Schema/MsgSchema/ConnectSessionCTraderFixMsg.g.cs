// <auto-generated>
//     Generated SBE (Simple Binary Encoding) message codec
// </auto-generated>

#pragma warning disable 1591 // disable warning on missing comments
using System;
using System.Text;
using Org.SbeTool.Sbe.Dll;

namespace MsgSchema
{
    /// <summary>
    /// Connection for CTraderFix
    /// </summary>
    public sealed partial class ConnectSessionCTraderFixMsg
    {
        public const ushort BlockLength = (ushort)311;
        public const ushort TemplateId = (ushort)14;
        public const ushort SchemaId = (ushort)3;
        public const ushort SchemaVersion = (ushort)0;
        public const string SemanticType = "";

        private readonly ConnectSessionCTraderFixMsg _parentMessage;
        private DirectBuffer _buffer;
        private int _offset;
        private int _limit;
        private int _actingBlockLength;
        private int _actingVersion;

        public int Offset { get { return _offset; } }

        public ConnectSessionCTraderFixMsg()
        {
            _parentMessage = this;
        }

        public void WrapForEncode(DirectBuffer buffer, int offset)
        {
            _buffer = buffer;
            _offset = offset;
            _actingBlockLength = BlockLength;
            _actingVersion = SchemaVersion;
            Limit = offset + _actingBlockLength;
        }

        public void WrapForEncodeAndApplyHeader(DirectBuffer buffer, int offset,  MessageHeader headerEncoder)
        {
            headerEncoder.Wrap(buffer, offset, SchemaVersion);
            headerEncoder.BlockLength = BlockLength;
            headerEncoder.TemplateId = TemplateId;
            headerEncoder.SchemaId = SchemaId;
            headerEncoder.Version = SchemaVersion;
            
            WrapForEncode(buffer, offset + MessageHeader.Size);
        }

        public void WrapForDecode(DirectBuffer buffer, int offset, int actingBlockLength, int actingVersion)
        {
            _buffer = buffer;
            _offset = offset;
            _actingBlockLength = actingBlockLength;
            _actingVersion = actingVersion;
            Limit = offset + _actingBlockLength;
        }

        public int Size
        {
            get
            {
                return _limit - _offset;
            }
        }

        public int Limit
        {
            get
            {
                return _limit;
            }
            set
            {
                _buffer.CheckLimit(value);
                _limit = value;
            }
        }


        public const int SessionIdId = 1;
    public const int SessionIdSinceVersion = 0;
    public const int SessionIdDeprecated = 0;
    public bool SessionIdInActingVersion()
    {
        return _actingVersion >= SessionIdSinceVersion;
    }

        public const int SessionIdOffset = 0;

        public static string SessionIdMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const ushort SessionIdNullValue = (ushort)65535;
        public const ushort SessionIdMinValue = (ushort)0;
        public const ushort SessionIdMaxValue = (ushort)65534;

        public ushort SessionId
        {
            get
            {
                return _buffer.Uint16GetLittleEndian(_offset + 0);
            }
            set
            {
                _buffer.Uint16PutLittleEndian(_offset + 0, value);
            }
        }


        public const int SenderCompIdQuoteId = 2;
    public const int SenderCompIdQuoteSinceVersion = 0;
    public const int SenderCompIdQuoteDeprecated = 0;
    public bool SenderCompIdQuoteInActingVersion()
    {
        return _actingVersion >= SenderCompIdQuoteSinceVersion;
    }

        public const int SenderCompIdQuoteOffset = 2;

        public static string SenderCompIdQuoteMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const byte SenderCompIdQuoteNullValue = (byte)0;
        public const byte SenderCompIdQuoteMinValue = (byte)32;
        public const byte SenderCompIdQuoteMaxValue = (byte)126;

        public const int SenderCompIdQuoteLength = 40;

        public byte GetSenderCompIdQuote(int index)
        {
            if ((uint) index >= 40)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            return _buffer.CharGet(_offset + 2 + (index * 1));
        }

        public void SetSenderCompIdQuote(int index, byte value)
        {
            if ((uint) index >= 40)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            _buffer.CharPut(_offset + 2 + (index * 1), value);
        }

        public ReadOnlySpan<byte> SenderCompIdQuote
        {
            get => _buffer.AsReadOnlySpan<byte>(_offset + 2, SenderCompIdQuoteLength);
            set => value.CopyTo(_buffer.AsSpan<byte>(_offset + 2, SenderCompIdQuoteLength));
        }

        public Span<byte> SenderCompIdQuoteAsSpan()
        {
            return _buffer.AsSpan<byte>(_offset + 2, SenderCompIdQuoteLength);
        }

        public const string SenderCompIdQuoteCharacterEncoding = "ASCII";
        public static Encoding SenderCompIdQuoteResolvedCharacterEncoding = Encoding.GetEncoding(SenderCompIdQuoteCharacterEncoding);


        public int GetSenderCompIdQuote(byte[] dst, int dstOffset)
        {
            const int length = 40;
            return GetSenderCompIdQuote(new Span<byte>(dst, dstOffset, length));
        }

        public int GetSenderCompIdQuote(Span<byte> dst)
        {
            const int length = 40;
            if (dst.Length < length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooSmall(dst.Length);
            }

            _buffer.GetBytes(_offset + 2, dst);
            return length;
        }

        public void SetSenderCompIdQuote(byte[] src, int srcOffset)
        {
            SetSenderCompIdQuote(new ReadOnlySpan<byte>(src, srcOffset, src.Length - srcOffset));
        }

        public void SetSenderCompIdQuote(ReadOnlySpan<byte> src)
        {
            const int length = 40;
            if (src.Length > length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooLarge(src.Length);
            }

            _buffer.SetBytes(_offset + 2, src);
        }

        public void SetSenderCompIdQuote(string value)
        {
            _buffer.SetNullTerminatedBytesFromString(SenderCompIdQuoteResolvedCharacterEncoding, value, _offset + 2, SenderCompIdQuoteLength, SenderCompIdQuoteNullValue);
        }
        public string GetSenderCompIdQuote()
        {
            return _buffer.GetStringFromNullTerminatedBytes(SenderCompIdQuoteResolvedCharacterEncoding, _offset + 2, SenderCompIdQuoteLength, SenderCompIdQuoteNullValue);
        }

        public const int SenderCompIdTradeId = 3;
    public const int SenderCompIdTradeSinceVersion = 0;
    public const int SenderCompIdTradeDeprecated = 0;
    public bool SenderCompIdTradeInActingVersion()
    {
        return _actingVersion >= SenderCompIdTradeSinceVersion;
    }

        public const int SenderCompIdTradeOffset = 42;

        public static string SenderCompIdTradeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const byte SenderCompIdTradeNullValue = (byte)0;
        public const byte SenderCompIdTradeMinValue = (byte)32;
        public const byte SenderCompIdTradeMaxValue = (byte)126;

        public const int SenderCompIdTradeLength = 40;

        public byte GetSenderCompIdTrade(int index)
        {
            if ((uint) index >= 40)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            return _buffer.CharGet(_offset + 42 + (index * 1));
        }

        public void SetSenderCompIdTrade(int index, byte value)
        {
            if ((uint) index >= 40)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            _buffer.CharPut(_offset + 42 + (index * 1), value);
        }

        public ReadOnlySpan<byte> SenderCompIdTrade
        {
            get => _buffer.AsReadOnlySpan<byte>(_offset + 42, SenderCompIdTradeLength);
            set => value.CopyTo(_buffer.AsSpan<byte>(_offset + 42, SenderCompIdTradeLength));
        }

        public Span<byte> SenderCompIdTradeAsSpan()
        {
            return _buffer.AsSpan<byte>(_offset + 42, SenderCompIdTradeLength);
        }

        public const string SenderCompIdTradeCharacterEncoding = "ASCII";
        public static Encoding SenderCompIdTradeResolvedCharacterEncoding = Encoding.GetEncoding(SenderCompIdTradeCharacterEncoding);


        public int GetSenderCompIdTrade(byte[] dst, int dstOffset)
        {
            const int length = 40;
            return GetSenderCompIdTrade(new Span<byte>(dst, dstOffset, length));
        }

        public int GetSenderCompIdTrade(Span<byte> dst)
        {
            const int length = 40;
            if (dst.Length < length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooSmall(dst.Length);
            }

            _buffer.GetBytes(_offset + 42, dst);
            return length;
        }

        public void SetSenderCompIdTrade(byte[] src, int srcOffset)
        {
            SetSenderCompIdTrade(new ReadOnlySpan<byte>(src, srcOffset, src.Length - srcOffset));
        }

        public void SetSenderCompIdTrade(ReadOnlySpan<byte> src)
        {
            const int length = 40;
            if (src.Length > length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooLarge(src.Length);
            }

            _buffer.SetBytes(_offset + 42, src);
        }

        public void SetSenderCompIdTrade(string value)
        {
            _buffer.SetNullTerminatedBytesFromString(SenderCompIdTradeResolvedCharacterEncoding, value, _offset + 42, SenderCompIdTradeLength, SenderCompIdTradeNullValue);
        }
        public string GetSenderCompIdTrade()
        {
            return _buffer.GetStringFromNullTerminatedBytes(SenderCompIdTradeResolvedCharacterEncoding, _offset + 42, SenderCompIdTradeLength, SenderCompIdTradeNullValue);
        }

        public const int TargetCompIdQuoteId = 4;
    public const int TargetCompIdQuoteSinceVersion = 0;
    public const int TargetCompIdQuoteDeprecated = 0;
    public bool TargetCompIdQuoteInActingVersion()
    {
        return _actingVersion >= TargetCompIdQuoteSinceVersion;
    }

        public const int TargetCompIdQuoteOffset = 82;

        public static string TargetCompIdQuoteMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const byte TargetCompIdQuoteNullValue = (byte)0;
        public const byte TargetCompIdQuoteMinValue = (byte)32;
        public const byte TargetCompIdQuoteMaxValue = (byte)126;

        public const int TargetCompIdQuoteLength = 40;

        public byte GetTargetCompIdQuote(int index)
        {
            if ((uint) index >= 40)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            return _buffer.CharGet(_offset + 82 + (index * 1));
        }

        public void SetTargetCompIdQuote(int index, byte value)
        {
            if ((uint) index >= 40)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            _buffer.CharPut(_offset + 82 + (index * 1), value);
        }

        public ReadOnlySpan<byte> TargetCompIdQuote
        {
            get => _buffer.AsReadOnlySpan<byte>(_offset + 82, TargetCompIdQuoteLength);
            set => value.CopyTo(_buffer.AsSpan<byte>(_offset + 82, TargetCompIdQuoteLength));
        }

        public Span<byte> TargetCompIdQuoteAsSpan()
        {
            return _buffer.AsSpan<byte>(_offset + 82, TargetCompIdQuoteLength);
        }

        public const string TargetCompIdQuoteCharacterEncoding = "ASCII";
        public static Encoding TargetCompIdQuoteResolvedCharacterEncoding = Encoding.GetEncoding(TargetCompIdQuoteCharacterEncoding);


        public int GetTargetCompIdQuote(byte[] dst, int dstOffset)
        {
            const int length = 40;
            return GetTargetCompIdQuote(new Span<byte>(dst, dstOffset, length));
        }

        public int GetTargetCompIdQuote(Span<byte> dst)
        {
            const int length = 40;
            if (dst.Length < length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooSmall(dst.Length);
            }

            _buffer.GetBytes(_offset + 82, dst);
            return length;
        }

        public void SetTargetCompIdQuote(byte[] src, int srcOffset)
        {
            SetTargetCompIdQuote(new ReadOnlySpan<byte>(src, srcOffset, src.Length - srcOffset));
        }

        public void SetTargetCompIdQuote(ReadOnlySpan<byte> src)
        {
            const int length = 40;
            if (src.Length > length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooLarge(src.Length);
            }

            _buffer.SetBytes(_offset + 82, src);
        }

        public void SetTargetCompIdQuote(string value)
        {
            _buffer.SetNullTerminatedBytesFromString(TargetCompIdQuoteResolvedCharacterEncoding, value, _offset + 82, TargetCompIdQuoteLength, TargetCompIdQuoteNullValue);
        }
        public string GetTargetCompIdQuote()
        {
            return _buffer.GetStringFromNullTerminatedBytes(TargetCompIdQuoteResolvedCharacterEncoding, _offset + 82, TargetCompIdQuoteLength, TargetCompIdQuoteNullValue);
        }

        public const int TargetCompIdTradeId = 5;
    public const int TargetCompIdTradeSinceVersion = 0;
    public const int TargetCompIdTradeDeprecated = 0;
    public bool TargetCompIdTradeInActingVersion()
    {
        return _actingVersion >= TargetCompIdTradeSinceVersion;
    }

        public const int TargetCompIdTradeOffset = 122;

        public static string TargetCompIdTradeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const byte TargetCompIdTradeNullValue = (byte)0;
        public const byte TargetCompIdTradeMinValue = (byte)32;
        public const byte TargetCompIdTradeMaxValue = (byte)126;

        public const int TargetCompIdTradeLength = 40;

        public byte GetTargetCompIdTrade(int index)
        {
            if ((uint) index >= 40)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            return _buffer.CharGet(_offset + 122 + (index * 1));
        }

        public void SetTargetCompIdTrade(int index, byte value)
        {
            if ((uint) index >= 40)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            _buffer.CharPut(_offset + 122 + (index * 1), value);
        }

        public ReadOnlySpan<byte> TargetCompIdTrade
        {
            get => _buffer.AsReadOnlySpan<byte>(_offset + 122, TargetCompIdTradeLength);
            set => value.CopyTo(_buffer.AsSpan<byte>(_offset + 122, TargetCompIdTradeLength));
        }

        public Span<byte> TargetCompIdTradeAsSpan()
        {
            return _buffer.AsSpan<byte>(_offset + 122, TargetCompIdTradeLength);
        }

        public const string TargetCompIdTradeCharacterEncoding = "ASCII";
        public static Encoding TargetCompIdTradeResolvedCharacterEncoding = Encoding.GetEncoding(TargetCompIdTradeCharacterEncoding);


        public int GetTargetCompIdTrade(byte[] dst, int dstOffset)
        {
            const int length = 40;
            return GetTargetCompIdTrade(new Span<byte>(dst, dstOffset, length));
        }

        public int GetTargetCompIdTrade(Span<byte> dst)
        {
            const int length = 40;
            if (dst.Length < length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooSmall(dst.Length);
            }

            _buffer.GetBytes(_offset + 122, dst);
            return length;
        }

        public void SetTargetCompIdTrade(byte[] src, int srcOffset)
        {
            SetTargetCompIdTrade(new ReadOnlySpan<byte>(src, srcOffset, src.Length - srcOffset));
        }

        public void SetTargetCompIdTrade(ReadOnlySpan<byte> src)
        {
            const int length = 40;
            if (src.Length > length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooLarge(src.Length);
            }

            _buffer.SetBytes(_offset + 122, src);
        }

        public void SetTargetCompIdTrade(string value)
        {
            _buffer.SetNullTerminatedBytesFromString(TargetCompIdTradeResolvedCharacterEncoding, value, _offset + 122, TargetCompIdTradeLength, TargetCompIdTradeNullValue);
        }
        public string GetTargetCompIdTrade()
        {
            return _buffer.GetStringFromNullTerminatedBytes(TargetCompIdTradeResolvedCharacterEncoding, _offset + 122, TargetCompIdTradeLength, TargetCompIdTradeNullValue);
        }

        public const int HostQuoteId = 6;
    public const int HostQuoteSinceVersion = 0;
    public const int HostQuoteDeprecated = 0;
    public bool HostQuoteInActingVersion()
    {
        return _actingVersion >= HostQuoteSinceVersion;
    }

        public const int HostQuoteOffset = 162;

        public static string HostQuoteMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const byte HostQuoteNullValue = (byte)0;
        public const byte HostQuoteMinValue = (byte)32;
        public const byte HostQuoteMaxValue = (byte)126;

        public const int HostQuoteLength = 50;

        public byte GetHostQuote(int index)
        {
            if ((uint) index >= 50)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            return _buffer.CharGet(_offset + 162 + (index * 1));
        }

        public void SetHostQuote(int index, byte value)
        {
            if ((uint) index >= 50)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            _buffer.CharPut(_offset + 162 + (index * 1), value);
        }

        public ReadOnlySpan<byte> HostQuote
        {
            get => _buffer.AsReadOnlySpan<byte>(_offset + 162, HostQuoteLength);
            set => value.CopyTo(_buffer.AsSpan<byte>(_offset + 162, HostQuoteLength));
        }

        public Span<byte> HostQuoteAsSpan()
        {
            return _buffer.AsSpan<byte>(_offset + 162, HostQuoteLength);
        }

        public const string HostQuoteCharacterEncoding = "ASCII";
        public static Encoding HostQuoteResolvedCharacterEncoding = Encoding.GetEncoding(HostQuoteCharacterEncoding);


        public int GetHostQuote(byte[] dst, int dstOffset)
        {
            const int length = 50;
            return GetHostQuote(new Span<byte>(dst, dstOffset, length));
        }

        public int GetHostQuote(Span<byte> dst)
        {
            const int length = 50;
            if (dst.Length < length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooSmall(dst.Length);
            }

            _buffer.GetBytes(_offset + 162, dst);
            return length;
        }

        public void SetHostQuote(byte[] src, int srcOffset)
        {
            SetHostQuote(new ReadOnlySpan<byte>(src, srcOffset, src.Length - srcOffset));
        }

        public void SetHostQuote(ReadOnlySpan<byte> src)
        {
            const int length = 50;
            if (src.Length > length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooLarge(src.Length);
            }

            _buffer.SetBytes(_offset + 162, src);
        }

        public void SetHostQuote(string value)
        {
            _buffer.SetNullTerminatedBytesFromString(HostQuoteResolvedCharacterEncoding, value, _offset + 162, HostQuoteLength, HostQuoteNullValue);
        }
        public string GetHostQuote()
        {
            return _buffer.GetStringFromNullTerminatedBytes(HostQuoteResolvedCharacterEncoding, _offset + 162, HostQuoteLength, HostQuoteNullValue);
        }

        public const int HostTradeId = 7;
    public const int HostTradeSinceVersion = 0;
    public const int HostTradeDeprecated = 0;
    public bool HostTradeInActingVersion()
    {
        return _actingVersion >= HostTradeSinceVersion;
    }

        public const int HostTradeOffset = 212;

        public static string HostTradeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const byte HostTradeNullValue = (byte)0;
        public const byte HostTradeMinValue = (byte)32;
        public const byte HostTradeMaxValue = (byte)126;

        public const int HostTradeLength = 50;

        public byte GetHostTrade(int index)
        {
            if ((uint) index >= 50)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            return _buffer.CharGet(_offset + 212 + (index * 1));
        }

        public void SetHostTrade(int index, byte value)
        {
            if ((uint) index >= 50)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            _buffer.CharPut(_offset + 212 + (index * 1), value);
        }

        public ReadOnlySpan<byte> HostTrade
        {
            get => _buffer.AsReadOnlySpan<byte>(_offset + 212, HostTradeLength);
            set => value.CopyTo(_buffer.AsSpan<byte>(_offset + 212, HostTradeLength));
        }

        public Span<byte> HostTradeAsSpan()
        {
            return _buffer.AsSpan<byte>(_offset + 212, HostTradeLength);
        }

        public const string HostTradeCharacterEncoding = "ASCII";
        public static Encoding HostTradeResolvedCharacterEncoding = Encoding.GetEncoding(HostTradeCharacterEncoding);


        public int GetHostTrade(byte[] dst, int dstOffset)
        {
            const int length = 50;
            return GetHostTrade(new Span<byte>(dst, dstOffset, length));
        }

        public int GetHostTrade(Span<byte> dst)
        {
            const int length = 50;
            if (dst.Length < length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooSmall(dst.Length);
            }

            _buffer.GetBytes(_offset + 212, dst);
            return length;
        }

        public void SetHostTrade(byte[] src, int srcOffset)
        {
            SetHostTrade(new ReadOnlySpan<byte>(src, srcOffset, src.Length - srcOffset));
        }

        public void SetHostTrade(ReadOnlySpan<byte> src)
        {
            const int length = 50;
            if (src.Length > length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooLarge(src.Length);
            }

            _buffer.SetBytes(_offset + 212, src);
        }

        public void SetHostTrade(string value)
        {
            _buffer.SetNullTerminatedBytesFromString(HostTradeResolvedCharacterEncoding, value, _offset + 212, HostTradeLength, HostTradeNullValue);
        }
        public string GetHostTrade()
        {
            return _buffer.GetStringFromNullTerminatedBytes(HostTradeResolvedCharacterEncoding, _offset + 212, HostTradeLength, HostTradeNullValue);
        }

        public const int PortQuoteId = 8;
    public const int PortQuoteSinceVersion = 0;
    public const int PortQuoteDeprecated = 0;
    public bool PortQuoteInActingVersion()
    {
        return _actingVersion >= PortQuoteSinceVersion;
    }

        public const int PortQuoteOffset = 262;

        public static string PortQuoteMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const ushort PortQuoteNullValue = (ushort)65535;
        public const ushort PortQuoteMinValue = (ushort)0;
        public const ushort PortQuoteMaxValue = (ushort)65534;

        public ushort PortQuote
        {
            get
            {
                return _buffer.Uint16GetLittleEndian(_offset + 262);
            }
            set
            {
                _buffer.Uint16PutLittleEndian(_offset + 262, value);
            }
        }


        public const int PortTradeId = 9;
    public const int PortTradeSinceVersion = 0;
    public const int PortTradeDeprecated = 0;
    public bool PortTradeInActingVersion()
    {
        return _actingVersion >= PortTradeSinceVersion;
    }

        public const int PortTradeOffset = 264;

        public static string PortTradeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const ushort PortTradeNullValue = (ushort)65535;
        public const ushort PortTradeMinValue = (ushort)0;
        public const ushort PortTradeMaxValue = (ushort)65534;

        public ushort PortTrade
        {
            get
            {
                return _buffer.Uint16GetLittleEndian(_offset + 264);
            }
            set
            {
                _buffer.Uint16PutLittleEndian(_offset + 264, value);
            }
        }


        public const int LoginQuoteId = 10;
    public const int LoginQuoteSinceVersion = 0;
    public const int LoginQuoteDeprecated = 0;
    public bool LoginQuoteInActingVersion()
    {
        return _actingVersion >= LoginQuoteSinceVersion;
    }

        public const int LoginQuoteOffset = 266;

        public static string LoginQuoteMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const ushort LoginQuoteNullValue = (ushort)65535;
        public const ushort LoginQuoteMinValue = (ushort)0;
        public const ushort LoginQuoteMaxValue = (ushort)65534;

        public ushort LoginQuote
        {
            get
            {
                return _buffer.Uint16GetLittleEndian(_offset + 266);
            }
            set
            {
                _buffer.Uint16PutLittleEndian(_offset + 266, value);
            }
        }


        public const int LoginTradeId = 11;
    public const int LoginTradeSinceVersion = 0;
    public const int LoginTradeDeprecated = 0;
    public bool LoginTradeInActingVersion()
    {
        return _actingVersion >= LoginTradeSinceVersion;
    }

        public const int LoginTradeOffset = 268;

        public static string LoginTradeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const ushort LoginTradeNullValue = (ushort)65535;
        public const ushort LoginTradeMinValue = (ushort)0;
        public const ushort LoginTradeMaxValue = (ushort)65534;

        public ushort LoginTrade
        {
            get
            {
                return _buffer.Uint16GetLittleEndian(_offset + 268);
            }
            set
            {
                _buffer.Uint16PutLittleEndian(_offset + 268, value);
            }
        }


        public const int PasswordQuoteId = 12;
    public const int PasswordQuoteSinceVersion = 0;
    public const int PasswordQuoteDeprecated = 0;
    public bool PasswordQuoteInActingVersion()
    {
        return _actingVersion >= PasswordQuoteSinceVersion;
    }

        public const int PasswordQuoteOffset = 270;

        public static string PasswordQuoteMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const byte PasswordQuoteNullValue = (byte)0;
        public const byte PasswordQuoteMinValue = (byte)32;
        public const byte PasswordQuoteMaxValue = (byte)126;

        public const int PasswordQuoteLength = 20;

        public byte GetPasswordQuote(int index)
        {
            if ((uint) index >= 20)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            return _buffer.CharGet(_offset + 270 + (index * 1));
        }

        public void SetPasswordQuote(int index, byte value)
        {
            if ((uint) index >= 20)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            _buffer.CharPut(_offset + 270 + (index * 1), value);
        }

        public ReadOnlySpan<byte> PasswordQuote
        {
            get => _buffer.AsReadOnlySpan<byte>(_offset + 270, PasswordQuoteLength);
            set => value.CopyTo(_buffer.AsSpan<byte>(_offset + 270, PasswordQuoteLength));
        }

        public Span<byte> PasswordQuoteAsSpan()
        {
            return _buffer.AsSpan<byte>(_offset + 270, PasswordQuoteLength);
        }

        public const string PasswordQuoteCharacterEncoding = "ASCII";
        public static Encoding PasswordQuoteResolvedCharacterEncoding = Encoding.GetEncoding(PasswordQuoteCharacterEncoding);


        public int GetPasswordQuote(byte[] dst, int dstOffset)
        {
            const int length = 20;
            return GetPasswordQuote(new Span<byte>(dst, dstOffset, length));
        }

        public int GetPasswordQuote(Span<byte> dst)
        {
            const int length = 20;
            if (dst.Length < length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooSmall(dst.Length);
            }

            _buffer.GetBytes(_offset + 270, dst);
            return length;
        }

        public void SetPasswordQuote(byte[] src, int srcOffset)
        {
            SetPasswordQuote(new ReadOnlySpan<byte>(src, srcOffset, src.Length - srcOffset));
        }

        public void SetPasswordQuote(ReadOnlySpan<byte> src)
        {
            const int length = 20;
            if (src.Length > length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooLarge(src.Length);
            }

            _buffer.SetBytes(_offset + 270, src);
        }

        public void SetPasswordQuote(string value)
        {
            _buffer.SetNullTerminatedBytesFromString(PasswordQuoteResolvedCharacterEncoding, value, _offset + 270, PasswordQuoteLength, PasswordQuoteNullValue);
        }
        public string GetPasswordQuote()
        {
            return _buffer.GetStringFromNullTerminatedBytes(PasswordQuoteResolvedCharacterEncoding, _offset + 270, PasswordQuoteLength, PasswordQuoteNullValue);
        }

        public const int PasswordTradeId = 13;
    public const int PasswordTradeSinceVersion = 0;
    public const int PasswordTradeDeprecated = 0;
    public bool PasswordTradeInActingVersion()
    {
        return _actingVersion >= PasswordTradeSinceVersion;
    }

        public const int PasswordTradeOffset = 290;

        public static string PasswordTradeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const byte PasswordTradeNullValue = (byte)0;
        public const byte PasswordTradeMinValue = (byte)32;
        public const byte PasswordTradeMaxValue = (byte)126;

        public const int PasswordTradeLength = 20;

        public byte GetPasswordTrade(int index)
        {
            if ((uint) index >= 20)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            return _buffer.CharGet(_offset + 290 + (index * 1));
        }

        public void SetPasswordTrade(int index, byte value)
        {
            if ((uint) index >= 20)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            _buffer.CharPut(_offset + 290 + (index * 1), value);
        }

        public ReadOnlySpan<byte> PasswordTrade
        {
            get => _buffer.AsReadOnlySpan<byte>(_offset + 290, PasswordTradeLength);
            set => value.CopyTo(_buffer.AsSpan<byte>(_offset + 290, PasswordTradeLength));
        }

        public Span<byte> PasswordTradeAsSpan()
        {
            return _buffer.AsSpan<byte>(_offset + 290, PasswordTradeLength);
        }

        public const string PasswordTradeCharacterEncoding = "ASCII";
        public static Encoding PasswordTradeResolvedCharacterEncoding = Encoding.GetEncoding(PasswordTradeCharacterEncoding);


        public int GetPasswordTrade(byte[] dst, int dstOffset)
        {
            const int length = 20;
            return GetPasswordTrade(new Span<byte>(dst, dstOffset, length));
        }

        public int GetPasswordTrade(Span<byte> dst)
        {
            const int length = 20;
            if (dst.Length < length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooSmall(dst.Length);
            }

            _buffer.GetBytes(_offset + 290, dst);
            return length;
        }

        public void SetPasswordTrade(byte[] src, int srcOffset)
        {
            SetPasswordTrade(new ReadOnlySpan<byte>(src, srcOffset, src.Length - srcOffset));
        }

        public void SetPasswordTrade(ReadOnlySpan<byte> src)
        {
            const int length = 20;
            if (src.Length > length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooLarge(src.Length);
            }

            _buffer.SetBytes(_offset + 290, src);
        }

        public void SetPasswordTrade(string value)
        {
            _buffer.SetNullTerminatedBytesFromString(PasswordTradeResolvedCharacterEncoding, value, _offset + 290, PasswordTradeLength, PasswordTradeNullValue);
        }
        public string GetPasswordTrade()
        {
            return _buffer.GetStringFromNullTerminatedBytes(PasswordTradeResolvedCharacterEncoding, _offset + 290, PasswordTradeLength, PasswordTradeNullValue);
        }

        public const int UseSslId = 14;
    public const int UseSslSinceVersion = 0;
    public const int UseSslDeprecated = 0;
    public bool UseSslInActingVersion()
    {
        return _actingVersion >= UseSslSinceVersion;
    }

        public const int UseSslOffset = 310;

        public static string UseSslMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public SslEncryption UseSsl
        {
            get
            {
                return (SslEncryption)_buffer.Uint8Get(_offset + 310);
            }
            set
            {
                _buffer.Uint8Put(_offset + 310, (byte)value);
            }
        }


        public override string ToString()
        {
            var sb = new StringBuilder(100);
            this.BuildString(sb);
            return sb.ToString();
        }

        internal void BuildString(StringBuilder builder)
        {
            if (_buffer == null)
            {
                throw new ArgumentNullException("_buffer");
            }

            int originalLimit = this.Limit;
            this.Limit = _offset + _actingBlockLength;
            builder.Append("[ConnectSessionCTraderFixMsg](sbeTemplateId=");
            builder.Append(ConnectSessionCTraderFixMsg.TemplateId);
            builder.Append("|sbeSchemaId=");
            builder.Append(ConnectSessionCTraderFixMsg.SchemaId);
            builder.Append("|sbeSchemaVersion=");
            if (_parentMessage._actingVersion != ConnectSessionCTraderFixMsg.SchemaVersion)
            {
                builder.Append(_parentMessage._actingVersion);
                builder.Append('/');
            }
            builder.Append(ConnectSessionCTraderFixMsg.SchemaVersion);
            builder.Append("|sbeBlockLength=");
            if (_actingBlockLength != ConnectSessionCTraderFixMsg.BlockLength)
            {
                builder.Append(_actingBlockLength);
                builder.Append('/');
            }
            builder.Append(ConnectSessionCTraderFixMsg.BlockLength);
            builder.Append("):");

            builder.Append("SessionId=");
            builder.Append(this.SessionId);
            builder.Append('|');
            builder.Append("SenderCompIdQuote=");
            for (int i = 0; i < SenderCompIdQuoteLength && this.GetSenderCompIdQuote(i) > 0; ++i)
            {
                builder.Append((char)this.GetSenderCompIdQuote(i));
            }
            builder.Append('|');
            builder.Append("SenderCompIdTrade=");
            for (int i = 0; i < SenderCompIdTradeLength && this.GetSenderCompIdTrade(i) > 0; ++i)
            {
                builder.Append((char)this.GetSenderCompIdTrade(i));
            }
            builder.Append('|');
            builder.Append("TargetCompIdQuote=");
            for (int i = 0; i < TargetCompIdQuoteLength && this.GetTargetCompIdQuote(i) > 0; ++i)
            {
                builder.Append((char)this.GetTargetCompIdQuote(i));
            }
            builder.Append('|');
            builder.Append("TargetCompIdTrade=");
            for (int i = 0; i < TargetCompIdTradeLength && this.GetTargetCompIdTrade(i) > 0; ++i)
            {
                builder.Append((char)this.GetTargetCompIdTrade(i));
            }
            builder.Append('|');
            builder.Append("HostQuote=");
            for (int i = 0; i < HostQuoteLength && this.GetHostQuote(i) > 0; ++i)
            {
                builder.Append((char)this.GetHostQuote(i));
            }
            builder.Append('|');
            builder.Append("HostTrade=");
            for (int i = 0; i < HostTradeLength && this.GetHostTrade(i) > 0; ++i)
            {
                builder.Append((char)this.GetHostTrade(i));
            }
            builder.Append('|');
            builder.Append("PortQuote=");
            builder.Append(this.PortQuote);
            builder.Append('|');
            builder.Append("PortTrade=");
            builder.Append(this.PortTrade);
            builder.Append('|');
            builder.Append("LoginQuote=");
            builder.Append(this.LoginQuote);
            builder.Append('|');
            builder.Append("LoginTrade=");
            builder.Append(this.LoginTrade);
            builder.Append('|');
            builder.Append("PasswordQuote=");
            for (int i = 0; i < PasswordQuoteLength && this.GetPasswordQuote(i) > 0; ++i)
            {
                builder.Append((char)this.GetPasswordQuote(i));
            }
            builder.Append('|');
            builder.Append("PasswordTrade=");
            for (int i = 0; i < PasswordTradeLength && this.GetPasswordTrade(i) > 0; ++i)
            {
                builder.Append((char)this.GetPasswordTrade(i));
            }
            builder.Append('|');
            builder.Append("UseSsl=");
            builder.Append(this.UseSsl);

            this.Limit = originalLimit;

        }
    }
}
